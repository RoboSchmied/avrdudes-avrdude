<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on January 8, 2023 by texi2html 5.0
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>AVRDUDE: 3.1 Terminal Mode Commands</title>

<meta name="description" content="AVRDUDE: 3.1 Terminal Mode Commands">
<meta name="keywords" content="AVRDUDE: 3.1 Terminal Mode Commands">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 5.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:pre}
span.nolinebreak {white-space:pre}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body { background-color: #ffd; }
h1 { text-shadow: .05em .05em #ccc; }
table {
  border: 3px solid #ccf;
  background-color: white;
}
div.smallexample {
  background-color: #dfd;
  border: 3px solid #cfc;
}
div.example {
  background-color: #dfd;
  border: 3px solid #cfc;
}
samp {
  color: blue;
}
code {
  color: green;
}

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Terminal-Mode-Commands"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_9.html#Configuration-File" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Introduction" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_40.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr>
<a name="index-Terminal-Mode"></a>
<a name="Terminal-Mode-Commands-1"></a>
<h2 class="section">3.1 Terminal Mode Commands</h2>

<p>The following commands are implemented for all programmers:
</p>
<dl compact="compact">
<dt><code>dump <var>memtype</var> <var>addr</var> <var>nbytes</var></code></dt>
<dd><p>Read <var>nbytes</var> from the specified memory area, and display them in
the usual hexadecimal and ASCII form.
</p>
</dd>
<dt><code>dump <var>memtype</var> <var>addr</var> &hellip;</code></dt>
<dd><p>Start reading from <var>addr</var>, all the way to the last memory address.
</p>
</dd>
<dt><code>dump <var>memtype</var> <var>addr</var></code></dt>
<dd><p>Read 256 bytes from the specified memory area, and display them.
</p>
</dd>
<dt><code>dump <var>memtype</var> &hellip;</code></dt>
<dd><p>Read all bytes from the specified memory, and display them.
</p>
</dd>
<dt><code>dump <var>memtype</var></code></dt>
<dd><p>Continue dumping the memory contents for another <var>nbytes</var> where the
previous dump command left off.
</p>
</dd>
<dt><code>read</code></dt>
<dd><p>Can be used as an alias for dump.
</p>
</dd>
<dt><code>write <var>memtype</var> <var>addr</var> <var>data[,]</var> {<var>data[,]</var>}</code></dt>
<dd><p>Manually program the respective memory cells, starting at address
<var>addr</var>, using the data items provided. The terminal implements
reading from and writing to flash and EEPROM type memories normally
through a cache and paged access functions. All other memories are
directly written to without use of a cache. Some older parts without paged
access will also have flash and EEPROM directly accessed without cache.
</p>
<p>Items <var>data</var> can have the following formats:
</p>
<table>
<tr><td width="30%"><strong>Type</strong></td><td width="40%"><strong>Example</strong></td><td width="30%"><strong>Size (bytes)</strong></td></tr>
<tr><td width="30%">String</td><td width="40%"><code>&quot;Hello, world\n&quot;</code></td><td width="30%">varying</td></tr>
<tr><td width="30%">Character</td><td width="40%"><code>'A'</code></td><td width="30%">1</td></tr>
<tr><td width="30%">Decimal integer</td><td width="40%">12345</td><td width="30%">1, 2, 4, or 8</td></tr>
<tr><td width="30%">Octal integer</td><td width="40%">012345</td><td width="30%">1, 2, 4, or 8</td></tr>
<tr><td width="30%">Hexadecimal integer</td><td width="40%">0x12345</td><td width="30%">1, 2, 4, or 8</td></tr>
<tr><td width="30%">Float</td><td width="40%">3.1415926</td><td width="30%">4</td></tr>
<tr><td width="30%">Double</td><td width="40%">3.141592653589793D</td><td width="30%">8</td></tr>
</table>

<p><var>data</var>
can be hexadecimal, octal or decimal integers, floating point numbers
or C-style strings and characters. For integers, an optional case-insensitive
suffix specifies the data size as in the table below:
</p><dl compact="compact">
<dt><code>LL</code></dt>
<dd><p>8 bytes / 64 bits
</p></dd>
<dt><code>L</code></dt>
<dd><p>4 bytes / 32 bits
</p></dd>
<dt><code>H or S</code></dt>
<dd><p>2 bytes / 16 bits
</p></dd>
<dt><code>HH</code></dt>
<dd><p>1 byte / 8 bits
</p></dd>
</dl>

<p>Suffix <code>D</code> indicates a 64-bit double, <code>F</code> a 32-bit float, whilst a
floating point number without suffix defaults to 32-bit float. Hexadecimal
floating point notation is supported. An ambiguous trailing suffix, e.g.,
<code>0x1.8D</code>, is read as no-suffix float where <code>D</code> is part of the
mantissa; use a zero exponent <code>0x1.8p0D</code> to clarify.
</p>
<p>An optional <code>U</code> suffix makes integers unsigned. Ordinary <code>0x</code> hex
integers are always treated as unsigned. <code>+0x</code> or <code>-0x</code> hex
numbers are treated as signed unless they have a <code>U</code> suffix. Unsigned
integers cannot be larger than 2^64-1. If <var>n</var> is an unsigned integer then <var>-n</var>
is also a valid unsigned integer as in C. Signed integers must fall into
the [-2^63, 2^63-1] range or a correspondingly smaller range when a suffix
specifies a smaller type.
</p>
<p>Ordinary <code>0x</code> hex integers with <var>n</var> hex digits (counting leading
zeros) use the smallest size of one, two, four and eight bytes that can
accommodate any n-digit hex integer. If an integer suffix specifies a size
explicitly the corresponding number of least significant bytes are
written, and a warning shown if the number does not fit into the desired
representation. Otherwise, unsigned integers occupy the smallest of one,
two, four or eight bytes needed. Signed numbers are allowed to fit into
the smallest signed or smallest unsigned representation: For example,
<code>255</code> is stored as one byte as <code>255U</code> would fit in one byte,
though as a signed number it would not fit into a one-byte interval [-128,
127]. The number <code>-1</code> is stored in one byte whilst <code>-1U</code> needs
eight bytes as it is the same as <code>0xFFFFffffFFFFffffU</code>.
</p>
<p>One trailing comma at the end of data items is ignored to facilitate copy
and paste of lists.
</p>
</dd>
<dt><code>write <var>memtype</var> <var>addr</var> <var>length</var> <var>data[,]</var> {<var>data[,]</var>} &hellip;</code></dt>
<dd><p>The ellipses form &hellip; of write is similar to above, but <var>length</var>
byte of the memory are written. For that purpose, after writing the
initial items, the last <var>data</var> item is replicated as many times as
needed.
</p>
</dd>
<dt><code>flush</code></dt>
<dd><p>Synchronise with the device all pending cached writes to EEPROM or flash.
With some programmer and part combinations, flash (and sometimes EEPROM,
too) looks like a NOR memory, ie, one can only write 0 bits, not 1 bits.
When this is detected, either page erase is deployed (e.g., with parts that
have PDI/UPDI interfaces), or if that is not available, both EEPROM and
flash caches are fully read in, a chip erase command is issued and both
EEPROM and flash are written back to the device. Hence, it can take
minutes to ensure that a single previously cleared bit is set and,
therefore, this command should be used sparingly.
</p>
</dd>
<dt><code>abort</code></dt>
<dd><p>Normally, caches are only ever actually written to the device when using
<code>flush</code>, at the end of the terminal session after typing <code>quit</code>,
or after EOF on input is encountered. The <code>abort</code> command resets the
cache discarding all previous writes to the flash and EEPROM cache.
</p>
</dd>
<dt><code>erase</code></dt>
<dd><p>Perform a chip erase and discard all pending writes to EEPROM and flash.
</p>
</dd>
<dt><code>sig</code></dt>
<dd><p>Display the device signature bytes.
</p>
</dd>
<dt><code>part</code></dt>
<dd><p>Display the current part settings and parameters.  Includes chip
specific information including all memory types supported by the
device, read/write timing, etc.
</p>
</dd>
<dt><code>verbose [<var>level</var>]</code></dt>
<dd><p>Change (when <var>level</var> is provided), or display the verbosity
level.
The initial verbosity level is controlled by the number of <code>-v</code> options
given on the command line.
</p>
</dd>
<dt><code>quell [<var>level</var>]</code></dt>
<dd><p>Change (when <var>level</var> is provided), or display the quell
level. 1 is used to suppress progress reports. 2 or higher yields
progressively quieter operations. The initial quell level is controlled
by the number of <code>-q</code> options given on the command line.
</p>
</dd>
<dt><code>?</code></dt>
<dt><code>help</code></dt>
<dd><p>Give a short on-line summary of the available commands.
</p>
</dd>
<dt><code>quit</code></dt>
<dd><p>Leave terminal mode and thus AVRDUDE.
</p>
</dd>
</dl>

<p>In addition, the following commands are supported on some programmers:
</p>
<dl compact="compact">
<dt><code>pgerase <var>memory</var> <var>addr</var></code></dt>
<dd><p>Erase one page of the memory specified.
</p>
</dd>
<dt><code>send <var>b1</var> <var>b2</var> <var>b3</var> <var>b4</var></code></dt>
<dd><p>Send raw instruction codes to the AVR device. If you need access to a
feature of an AVR part that is not directly supported by AVRDUDE, this
command allows you to use it, even though AVRDUDE does not implement the
command. When using direct SPI mode, up to 3 bytes
can be omitted.
</p>
</dd>
<dt><code>spi</code></dt>
<dd><p>Enter direct SPI mode.  The <em>pgmled</em> pin acts as chip select.
<em>Only supported on parallel bitbang programmers, and partially by USBtiny.</em>
Chip Select must be externally held low for direct SPI when
using USBtinyISP, and send must be a multiple of four bytes.
</p>
</dd>
<dt><code>pgm</code></dt>
<dd><p>Return to programming mode (from direct SPI mode).
</p>
</dd>
<dt><code>vtarg <var>voltage</var></code></dt>
<dd><p>Set the target&rsquo;s supply voltage to <var>voltage</var> Volts.
</p>
</dd>
<dt><code>varef [<var>channel</var>] <var>voltage</var></code></dt>
<dd><p>Set the adjustable voltage source to <var>voltage</var> Volts.
This voltage is normally used to drive the target&rsquo;s
<em>Aref</em> input on the STK500 and STK600.
The STK600 offers two reference voltages, which can be
selected by the optional parameter <var>channel</var> (either
0 or 1).
</p>
</dd>
<dt><code>fosc <var>freq</var>[<code>M</code>|<code>k</code>]</code></dt>
<dd><p>Set the programming oscillator to <var>freq</var> Hz.
An optional trailing letter <code>M</code>
multiplies by 1E6, a trailing letter <code>k</code> by 1E3.
</p>
</dd>
<dt><code>fosc off</code></dt>
<dd><p>Turn the programming oscillator off.
</p>
</dd>
<dt><code>sck <var>period</var></code></dt>
<dd><p><em>STK500 and STK600 only:</em>
Set the SCK clock period to <var>period</var> microseconds.
<em>JTAG ICE only:</em>
Set the JTAG ICE bit clock period to <var>period</var> microseconds.
Note that unlike STK500 settings, this setting will be reverted to
its default value (approximately 1 microsecond) when the programming
software signs off from the JTAG ICE.
This parameter can also be used on the JTAG ICE mkII/3 to specify the
ISP clock period when operating the ICE in ISP mode.
</p>
</dd>
<dt><code>parms</code></dt>
<dd><p><em>STK500 and STK600 only:</em>
Display the current voltage and programming oscillator parameters.
<em>JTAG ICE only:</em>
Display the current target supply voltage and JTAG bit clock rate/period.
</p>
</dd>
</dl>

<hr>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_6.html#Terminal-Mode-Operation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_9.html#Configuration-File" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Introduction" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_40.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>January 8, 2023</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>.
 </font>
 <br>

</p>
</body>
</html>
